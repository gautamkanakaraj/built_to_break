# Wallet Engine Rebuild Phase: Hardened Architecture

## 1. System Architecture Flow
[Client] -> [JWT Auth] -> [FastAPI Router] -> [Secure CRUD Logic] -> [SQLAlchemy ORM] -> [PostgreSQL]

### Key Protection Layers:
- **Authentication**: JWT-based identity verification. Removed `user_id` from transfer bodies; identity is inferred from token.
- **Idempotency**: Unique `idempotency_key` enforced at the Database level via unique constraints.
- **Concurrency**: Row-level locking using `SELECT ... FOR UPDATE` with deterministic ordering (Low ID first) to prevent deadlocks.
- **Atomicity**: Single Database Transaction per transfer.
- **Invariant Enforcement**: DB-level `CheckConstraint` (`balance >= 0`).

---

## 2. Database Schema (Hardened)

```text
+------------------+          +------------------+          +-----------------------+
|      users       |          |     wallets      |          |     transactions      |
+------------------+          +------------------+          +-----------------------+
| id (PK)          | <---+    | id (PK)          | <---+    | id (PK)               |
| username (Unique)|     |    | user_id (FK)     |     |    | from_wallet_id (FK)   |
| email            |     +--- | balance (Float)  |     +--- | to_wallet_id (FK)     |
+------------------+          | status (Enum)    |     |    | amount (Float)        |
                              +------------------+     |    | timestamp (DateTime)  |
                              | CONSTRAINT       |     |    | idempotency_key (UQ)  |
                              | balance >= 0     |     +----+-----------------------+
                              +------------------+
```

---

## 3. Failure -> Fix Mapping

| Failure (Build Phase) | Mapping Fix (Rebuild Phase) |
| :--- | :--- |
| **Double Spend** | `SELECT ... FOR UPDATE` row locking prevents concurrent debits from same source. |
| **Race Condition** | Deterministic lock ordering (min ID, then max ID) prevents deadlocks during high-concurrency loops. |
| **Partial Execution** | Multi-step logic wrapped in single atomic DB transaction. Invariants (CheckConstraint) prevent negative balance commit. |
| **Replay Attack** | Unique `idempotency_key` index ensures the same request can never execute twice. |
| **Read Skew** | New `/balances` endpoint performs bulk read in a single statement, providing a consistent snapshot. |

---

## 4. Before vs After Comparison

| Feature | Build Phase (Fragile) | Rebuild Phase (Hardened) |
| :--- | :--- | :--- |
| **Logic Location** | Application-only validation. | Database-backed enforcement (Constraints + Locks). |
| **Atomicity** | Multiple commits or client-orchestrated. | Single atomic DB transaction. |
| **Concurrency** | "No locking", causing race conditions. | Pessimistic locking (row-level). |
| **Idempotency** | Completely absent; replays cause multi-debit. | Unique request keys prevent duplication. |
| **Interface** | Unauthenticated; insecure. | JWT-protected and validated. |

---

## 5. Verification Results (Proof of Correctness)

- `test_idempotency.py` -> **PASS**: Attempted 5 replays; only 1 transaction executed.
- `test_atomicity.py` -> **PASS**: Malicious manual withdrawal attempts blocked by API validation.
- `isolation_test.py` -> **PASS**: 10s of high-concurrency transfers showed zero invariant violations (sum balance constant).
